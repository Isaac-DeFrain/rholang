\documentclass[12pt]{article}

\pagestyle{plain}
\usepackage{hyperref}
\usepackage{multicol}

%to suppress page numbers, change to pagestyle{empty}

%%% Special symbol packages %%%


\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{amsopn}
\usepackage{stmaryrd}



%%%%Page size controls %%%
%%%%Changing textwidth requires adjusting oddsidemargin

\setlength{\textwidth}{7 in}
\setlength{\textheight}{9.25 in}
\setlength{\headheight}{0 in}
\setlength{\headsep}{0 in}
\setlength{\topmargin}{0 in}
\setlength{\oddsidemargin}{-.25 in}

%%%special symbols%%%

\newcommand {\qed} {$\blacksquare$}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\zbar}{\overline{z}}
\newcommand{\OO}{\Omega}
\newcommand{\oo}{\omega}
\newcommand{\ra}{\rightarrow}

%%%environment controls%%%

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}[theorem]{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}[theorem]{Example}
\newtheorem{examples}[theorem]{Examples}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{question}[theorem]{Question}
\numberwithin{equation}{section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\author{Greg Meredith, Isaac DeFrain}
\date{}
\title{Rholang Program Visualization}

\maketitle
This note describes a means of producing a geometric shape for Rholang programs; more generally, a slight modification will produce a shape for any term of any computational calculus. \\

Let $\mathcal{T}$ denote the (finite) collection of term constructors and
\[ \mathcal{T}_+ := \{ t \in \mathcal{T} : \text{arity}(t)>0 \} \]
\[ \mathcal{T}_0 := \{ t \in \mathcal{T} : \text{arity}(t)=0 \} \]
Thus, we have $\mathcal{T} = \mathcal{T}_+ \cup \mathcal{T}_0$ and  $\mathcal{T}_+ \cap \mathcal{T}_0 = \emptyset$. Also, let $n = |\mathcal{T}_0| < \infty$ and $m = |\mathcal{T}_+| < \infty$.

Each $t \in \mathcal{T}$ is associated with an orthogonal direction, $d(t)$, in $(m+n)$-dimensional Euclidean space, i.e. a unit vector, such that $d(t) \perp d(t')$ if $t \neq t' \in \mathcal{T}$. The shape of each $z \in \mathcal{T}_0$ is a unique point, $p( z )$, in $(m+n)$-dimensional Euclidean space.

We generate the shape of a Rholang program (term) recursively.

\subsection*{Algorithm}
\begin{enumerate}
\item For each term $P$, there exists a top-level term constructor $t$ and $k \in \NN$ such that $P = t(P_1, \dots, P_k)$. Thus,
\[ \text{shape}(P) = \text{shape}( t(P_1, \dots, P_k) ) \]

\item Let $s_i := \text{shape}(P_i)$, $1 \leq i \leq k$, and $(s'_1, \dots, s'_k) := \text{displace}(s_1, \dots, s_k)$, where $\text{displace}(s_1, ..., s_k)$ checks if $s_1 \cap \cdots \cap s_k = \emptyset$ and displaces $s_1, \dots, s_k$ in the direction of their respective top-level term constructor, one unit at a time, until they are no longer overlapping.

\item Let $B(P)$ be the minimal bounding sphere of the shapes $s'_1, \dots, s'_k$. 

\item Let $b_i := \text{barycenter}(s'_i)$, $1 \leq i \leq k$, and $b := \text{barycenter}(s'_1, \dots, s'_k)$, i.e.
\[ b = \frac{\sum_{i=1}^k b_i \cdot \text{mass}(s_i)}{\sum_{i=1}^k \text{mass}(s_i)} \]
(WLOG mass = volume)

\item Let $d := \text{dist}(b, \partial B(P); d(t))$, where $\text{dist}(x,S;u)$ is the distance from the point $x$ to the set $S$ in the direction of the vector $u$.

\item Let $p_t$ be the point at a distance $2d$ from $b$ in the direction of $d(t)$, i.e. $2d = \text{dist}(b, p_t; d(t))$.

\item $(b_1, \dots, b_k).map(x) \Rightarrow line(p_t, x) \cup \{s'_1, \dots, s'_k \}$ \\
Meaning that for each $b_i$ we union the line segment joining $p_t$ and $b_i$, $line(p_t, b_i)$, with the displaced shape $s'_i$.

Thus, we have
\[ \text{shape}(P) = \cup_{i=1}^{k} \{ line(p_t, b_i)  \cup s_i' \} \]
\end{enumerate}

The geometric shape associated to the term $P$ is recursively generated by this algorithm.

\subsection*{Example:}

\[ P ::= 0 \ | \ \text{for}(x \leftarrow x )\{ P \} \ | \ x!(P) \ | \ P|P \ | \ {}^*x \]
\[ x ::= @P \]

In this case, $\mathcal{T}_0 = \{ 0 \}$, $\mathcal{T}_+ = \{ \text{for}( @\_ \leftarrow @\_ )\{ \_ \}, @\_ !( \_ ), \_ | \_, {}^*(@\_) \}$, and $|\mathcal{T}| = 5$. \\

Thus, 0 is a point in 5-dimensional Euclidean space. WLOG, we can take \\
$\text{shape}(0) = p(0) = (0, 0, 0, 0)$ \\
$d(0) = (1,0,0,0,0)$ \\
$d(\text{for}( @\_ \leftarrow @\_ )\{ \_ \})$ to be the unit vector $(0,1,0,0,0)$ \\
$d(@\_ !( \_ ) )$ to be the unit vector $(0,0,1,0,0)$ \\
$d(\_ | \_ )$ to be the unit vector $(0,0,0,1,0)$ \\
$d( {}^*(@\_) )$ to be the unit vector $(0,0,0,0,1)$ \\

%$boundingSphere( { ( 0, 0, 0, 0 ) } ) = unitSphere$ (around the origin)

The algorithm describes a means of producing 5-dimensional shapes from Rholang programs. \\

The send $@0!(0)$ forms a v shape with vertex on the ``send"-axis (spanned by $(0,0,1,0,0)$) and terminals on the ``0"-axis (spanned by $(1,0,0,0,0)$): \\

\noindent $\text{shape}(@0!(0)) = \text{shape}(@\_!(\_)(0,0)) = line((0,0,0,0,0),(0,0,1,0,0)) \ \cup \ line((0,0,1,0,0),(1,0,0,0,0))$ \\

The receive $\text{for}(@0 \leftarrow @0)\{ 0 \}$ forms a ``three-pronged" v shape with vertex on the ``for"-axis (spanned by $(0,1,0,0,0)$) and terminals on the ``0"-axis (spanned by $(1,0,0,0,0)$): \\

\noindent $\text{shape}(\text{for}(@0 \leftarrow @0)\{ 0 \}) = \text{shape}(\text{for}( @\_ \leftarrow @\_ )\{ \_ \})(0,0,0) = $
\[ line((0,0,0,0,0),(0,2,0,0,0)) \ \cup \ line((1,0,0,0,0),(0,2,0,0,0)) \ \cup \ line((2,0,0,0,0),(0,2,0,0,0)) \]

The shape of a simple comm event, $\text{for}(@0 \leftarrow @0)\{ 0 \} \ | \ @0!(0)$, is a two-pronged v (coming from the par) with a two-pronged v (coming from the send) at the end of one prong and a three-pronged v (coming from the receive) at the end of the other prong. It turns out that the ``send" v is not connected to ``par" v.

\end{document}

